<!doctype html>
<html>
  <head>
    <title>Extract Animated Models (With Filtered Animations)</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <h1>Extracting Animated Models (With Filtered Animations)...</h1>
    <div id="progress"></div>

    <script type="module">
      import * as THREE from 'three'
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
      import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js'

      const progressDiv = document.getElementById('progress')

      function updateProgress(message) {
        console.log(message)
        progressDiv.innerHTML += message + '<br>'
      }

      const loader = new GLTFLoader()
      const exporter = new GLTFExporter()

      updateProgress('Loading models GLB file...')

      loader.load(
        './models/beautiful_realistic_undressed_girls_-_14_anims.glb',
        (gltf) => {
          updateProgress('GLB file loaded successfully')

          const scene = gltf.scene
          const objects = []

          // Find GLTF_SceneRootNode and get its children
          let gltfRootNode = null
          scene.traverse((child) => {
            if (child.name === 'GLTF_SceneRootNode') {
              gltfRootNode = child
            }
          })

          if (gltfRootNode) {
            updateProgress(
              `Found GLTF_SceneRootNode with ${gltfRootNode.children.length} children`
            )

            gltfRootNode.children.forEach((child, index) => {
              let meshCount = 0
              child.traverse((descendant) => {
                if (descendant.isMesh) meshCount++
              })

              if (meshCount > 0) {
                objects.push(child)
                updateProgress(
                  `Child ${index + 1}: "${child.name || 'unnamed'}" (${meshCount} meshes)`
                )
              }
            })
          }

          updateProgress(`Total objects found: ${objects.length}`)

          // Get all animations from the GLTF file
          const allAnimations = gltf.animations || []
          updateProgress(`Found ${allAnimations.length} animations in the file`)

          // Helper function to collect all bone names from an object
          function getBoneNamesFromObject(object) {
            const boneNames = new Set()
            object.traverse((child) => {
              if (child.isBone) {
                boneNames.add(child.name)
              }
            })
            return Array.from(boneNames)
          }

          let exportedCount = 0

          // Extract each object as a separate GLB file WITH filtered animations
          objects.forEach((obj, index) => {
            updateProgress(`\nProcessing object ${index + 1}: ${obj.name}`)

            // Collect bone names from this object
            const boneNames = getBoneNamesFromObject(obj)
            updateProgress(`  Found ${boneNames.length} bones in this object`)
            
            if (boneNames.length > 0) {
              updateProgress(`  Bone names: ${boneNames.slice(0, 5).join(', ')}${boneNames.length > 5 ? '...' : ''}`)
            }

            // Filter animations based on bone names
            const relatedAnimations = allAnimations
              .map((clip) => {
                const filteredTracks = clip.tracks.filter(track => {
                  return boneNames.some(boneName => track.name.startsWith(boneName))
                })
                if (filteredTracks.length > 0) {
                  const newClip = clip.clone()
                  newClip.tracks = filteredTracks
                  updateProgress(`  Found ${filteredTracks.length} animation tracks for bones`)
                  return newClip
                }
                return null
              })
              .filter(Boolean)

            updateProgress(`  Filtered ${relatedAnimations.length} animations for this character`)

            // Create a new scene with cloned object
            const newScene = new THREE.Scene()
            const characterGroup = obj.clone(true)
            
            // Position character with feet on ground
            const boundingBox = new THREE.Box3().setFromObject(characterGroup)
            const center = boundingBox.getCenter(new THREE.Vector3())
            const min = boundingBox.min
            
            // Move character so feet are at Y=0 and centered on X/Z axes
            characterGroup.position.set(-center.x, -min.y, -center.z)
            
            updateProgress(`  Character positioned: feet at Y=0, centered on X/Z axes`)
            
            newScene.add(characterGroup)

            // Find and copy all meshes and bones, maintaining hierarchy
            const meshes = []
            const bones = []
            const skinnedMeshes = []
            
            obj.traverse((child) => {
              if (child.isMesh) {
                meshes.push(child)
                if (child.isSkinnedMesh) {
                  skinnedMeshes.push(child)
                }
              }
              if (child.isBone || (child.type === 'Object3D' && child.name.includes('mixamorig'))) {
                bones.push(child)
              }
            })

            updateProgress(`  Found ${meshes.length} meshes (${skinnedMeshes.length} skinned) and ${bones.length} bones`)

            // Create a simplified version without complex skeleton structure
            meshes.forEach((mesh, meshIndex) => {
              // Create a completely new mesh
              const newGeometry = mesh.geometry.clone()
              const newMaterial = mesh.material.clone()

              // Ensure material is visible
              if (Array.isArray(newMaterial)) {
                newMaterial.forEach((mat) => {
                  mat.visible = true
                  mat.opacity = Math.max(mat.opacity, 1.0)
                })
              } else {
                newMaterial.visible = true
                newMaterial.opacity = Math.max(newMaterial.opacity, 1.0)
              }

              const newMesh = new THREE.Mesh(newGeometry, newMaterial)
              newMesh.name = mesh.name || `Mesh_${meshIndex}`

              // Copy the mesh's local transformation
              newMesh.position.copy(mesh.position)
              newMesh.rotation.copy(mesh.rotation)
              newMesh.scale.copy(mesh.scale)

              // Apply world matrix if needed
              mesh.updateMatrixWorld()
              newMesh.matrix.copy(mesh.matrixWorld)
              newMesh.matrix.decompose(newMesh.position, newMesh.quaternion, newMesh.scale)

              newMesh.castShadow = true
              newMesh.receiveShadow = true

              characterGroup.add(newMesh)

              updateProgress(
                `    Copied mesh: ${mesh.name} (${newGeometry.attributes.position.count} vertices)`
              )
            })

            // Calculate bounding box and position character with feet on ground
            const boundingBox = new THREE.Box3().setFromObject(characterGroup)
            const center = boundingBox.getCenter(new THREE.Vector3())
            const size = boundingBox.getSize(new THREE.Vector3())
            const min = boundingBox.min

            // Move character so feet are at Y=0 and centered on X/Z axes
            characterGroup.position.set(-center.x, -min.y, -center.z)

            // Apply only Z-axis rotation to preserve front-facing direction
            characterGroup.rotation.set(0, 0, 0)

            updateProgress(
              `  Character positioned: feet at Y=0, centered on X/Z axes`
            )
            updateProgress(
              `  Applied Z rotation only: ${obj.rotation.z.toFixed(2)} rad (${((obj.rotation.z * 180) / Math.PI).toFixed(1)}Â°)`
            )

            newScene.add(characterGroup)

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6)
            newScene.add(ambientLight)

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
            directionalLight.position.set(1, 1, 1)
            newScene.add(directionalLight)

            updateProgress(
              `  Character centered at origin, size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`
            )

            // Export as GLB WITH filtered animations
            exporter.parse(
              newScene,
              (result) => {
                const safeName = (obj.name || `character_${index + 1}`).replace(
                  /[^a-zA-Z0-9]/g,
                  '_'
                )
                const filename = `animated_${index + 1}_${safeName}.glb`

                exportedCount++

                // Create download link
                const blob = new Blob([result], {
                  type: 'application/octet-stream',
                })
                const url = URL.createObjectURL(blob)
                const a = document.createElement('a')
                a.href = url
                a.download = filename
                a.style.display = 'none'
                document.body.appendChild(a)
                a.click()
                document.body.removeChild(a)
                URL.revokeObjectURL(url)

                updateProgress(`âœ“ Exported with animation: ${filename}`)

                // Check if all objects have been exported
                if (exportedCount === objects.length) {
                  updateProgress(
                    '\nðŸŽ‰ All animated models exported successfully!'
                  )
                }
              },
              (error) => {
                updateProgress(`âŒ Error exporting ${obj.name}: ${error}`)
                exportedCount++

                if (exportedCount === objects.length) {
                  updateProgress(
                    '\nâš ï¸ Export process completed with some errors'
                  )
                }
              },
              {
                binary: true,
                animations: relatedAnimations
              }
            )
          })
        },
        undefined,
        (error) => {
          updateProgress(`Error loading GLB: ${error}`)
        }
      )
    </script>
  </body>
</html>
