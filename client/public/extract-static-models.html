<!doctype html>
<html>
  <head>
    <title>Extract Static Models (No Animation)</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <h1>Extracting Static Models (No Animation)...</h1>
    <div id="progress"></div>

    <script type="module">
      import * as THREE from 'three'
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
      import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js'

      const progressDiv = document.getElementById('progress')

      function updateProgress(message) {
        console.log(message)
        progressDiv.innerHTML += message + '<br>'
      }

      const loader = new GLTFLoader()
      const exporter = new GLTFExporter()

      updateProgress('Loading models GLB file...')

      loader.load(
        './models/girls_-_14_anims.glb',
        (gltf) => {
          updateProgress('GLB file loaded successfully')

          const scene = gltf.scene
          const objects = []

          // Find GLTF_SceneRootNode and get its children
          let gltfRootNode = null
          scene.traverse((child) => {
            if (child.name === 'GLTF_SceneRootNode') {
              gltfRootNode = child
            }
          })

          if (gltfRootNode) {
            updateProgress(
              `Found GLTF_SceneRootNode with ${gltfRootNode.children.length} children`
            )

            gltfRootNode.children.forEach((child, index) => {
              let meshCount = 0
              child.traverse((descendant) => {
                if (descendant.isMesh) meshCount++
              })

              if (meshCount > 0) {
                objects.push(child)
                updateProgress(
                  `Child ${index + 1}: "${child.name || 'unnamed'}" (${meshCount} meshes)`
                )
              }
            })
          }

          updateProgress(`Total objects found: ${objects.length}`)

          let exportedCount = 0

          // Extract each object as a separate GLB file WITHOUT animations
          objects.forEach((obj, index) => {
            updateProgress(`\nProcessing object ${index + 1}: ${obj.name}`)

            // Create a completely new, clean scene
            const newScene = new THREE.Scene()

            // Create a new group to hold this character
            const characterGroup = new THREE.Group()
            characterGroup.name = obj.name || `Character_${index + 1}`

            // Clone all meshes from the original object
            const meshes = []
            obj.traverse((child) => {
              if (child.isMesh) {
                meshes.push(child)
              }
            })

            updateProgress(`  Found ${meshes.length} meshes to copy`)

            meshes.forEach((mesh, meshIndex) => {
              // Create a completely new mesh
              const newGeometry = mesh.geometry.clone()
              const newMaterial = mesh.material.clone()

              // Ensure material is visible
              if (Array.isArray(newMaterial)) {
                newMaterial.forEach((mat) => {
                  mat.visible = true
                  mat.opacity = Math.max(mat.opacity, 1.0)
                })
              } else {
                newMaterial.visible = true
                newMaterial.opacity = Math.max(newMaterial.opacity, 1.0)
              }

              const newMesh = new THREE.Mesh(newGeometry, newMaterial)
              newMesh.name = mesh.name || `Mesh_${meshIndex}`

              // Copy the mesh's local transformation directly (not world matrix)
              newMesh.position.copy(mesh.position)
              newMesh.rotation.set(0, obj.rotation.z, 0)
              newMesh.scale.copy(mesh.scale)

              updateProgress(
                `      Mesh transform: pos(${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)}) rot(${mesh.rotation.x.toFixed(2)}, ${mesh.rotation.y.toFixed(2)}, ${mesh.rotation.z.toFixed(2)})`
              )

              newMesh.castShadow = true
              newMesh.receiveShadow = true

              characterGroup.add(newMesh)

              updateProgress(
                `    Copied mesh: ${mesh.name} (${newGeometry.attributes.position.count} vertices)`
              )
            })

            // Calculate bounding box and position character with feet on ground
            const boundingBox = new THREE.Box3().setFromObject(characterGroup)
            const center = boundingBox.getCenter(new THREE.Vector3())
            const size = boundingBox.getSize(new THREE.Vector3())
            const min = boundingBox.min

            // Move character so feet are at Y=0 and centered on X/Z axes
            characterGroup.position.set(-center.x, -min.y, -center.z)

            // Apply only Z-axis rotation to preserve front-facing direction
            characterGroup.rotation.set(0, 0, 0)

            updateProgress(
              `  Character positioned: feet at Y=0, centered on X/Z axes`
            )
            updateProgress(
              `  Applied Z rotation only: ${obj.rotation.z.toFixed(2)} rad (${((obj.rotation.z * 180) / Math.PI).toFixed(1)}°)`
            )

            newScene.add(characterGroup)

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6)
            newScene.add(ambientLight)

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
            directionalLight.position.set(1, 1, 1)
            newScene.add(directionalLight)

            updateProgress(
              `  Character centered at origin, size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`
            )

            // Export as GLB WITHOUT animations
            exporter.parse(
              newScene,
              (result) => {
                const safeName = (obj.name || `character_${index + 1}`).replace(
                  /[^a-zA-Z0-9]/g,
                  '_'
                )
                const filename = `static_${index + 1}_${safeName}.glb`

                exportedCount++

                // Create download link
                const blob = new Blob([result], {
                  type: 'application/octet-stream',
                })
                const url = URL.createObjectURL(blob)
                const a = document.createElement('a')
                a.href = url
                a.download = filename
                a.style.display = 'none'
                document.body.appendChild(a)
                a.click()
                document.body.removeChild(a)
                URL.revokeObjectURL(url)

                updateProgress(`✓ Exported: ${filename}`)

                // Check if all objects have been exported
                if (exportedCount === objects.length) {
                  updateProgress(
                    '\n🎉 All static models exported successfully!'
                  )
                }
              },
              (error) => {
                updateProgress(`❌ Error exporting ${obj.name}: ${error}`)
                exportedCount++

                if (exportedCount === objects.length) {
                  updateProgress(
                    '\n⚠️ Export process completed with some errors'
                  )
                }
              },
              {
                binary: true,
                animations: [], // No animations
              }
            )
          })
        },
        undefined,
        (error) => {
          updateProgress(`Error loading GLB: ${error}`)
        }
      )
    </script>
  </body>
</html>
