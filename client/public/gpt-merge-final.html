<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>GLB ì• ë‹ˆë©”ì´ì…˜ ë³‘í•©ê¸° (íœ´ë¦¬ìŠ¤í‹± ë§¤ì¹­ + í´ë¦½ëª… ê³ ìœ í™”)</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>
  <style>
    :root{color-scheme:dark}
    body{font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Apple Color Emoji,Noto Color Emoji,Helvetica,Arial,"Apple SD Gothic Neo","Malgun Gothic","ë§‘ì€ ê³ ë”•",sans-serif;line-height:1.45;padding:24px;background:#0b1020;color:#eef2ff}
    h1{font-size:20px;margin:0 0 6px 0}
    .row{margin:8px 0}
    button{padding:8px 12px;border-radius:10px;border:0;background:#5865f2;color:#fff;font-weight:600}
    button:disabled{opacity:.5}
    pre{white-space:pre-wrap;background:#111633;border-radius:12px;padding:12px;max-height:42vh;overflow:auto}
    .tip{opacity:.8;font-size:13px}
    .ok{color:#8df59b}
    .warn{color:#ffd166}
    .err{color:#ff6b6b}
    ul{margin:6px 0 0 16px;padding:0}
    .small{font-size:12px;opacity:.9}
  </style>
</head>
<body>
  <h1>GLB ì• ë‹ˆë©”ì´ì…˜ ë³‘í•©ê¸° (a êµ¬ì¡° ìœ ì§€)</h1>
  <div class="row">a.glb = êµ¬ì¡° ìœ ì§€í•  íŒŒì¼, b.glb = ì• ë‹ˆë©”ì´ì…˜ ê°€ì ¸ì˜¬ íŒŒì¼</div>
  <div class="row"><input type="file" id="fileA" accept=".glb,.gltf" /> a.glb</div>
  <div class="row"><input type="file" id="fileB" accept=".glb,.gltf" /> b.glb</div>
  <div class="row">
    <label class="small"><input type="checkbox" id="prefixB" checked /> b.glb í´ë¦½ëª… ì•ì— <code>b_</code> ì ‘ë‘ì‚¬ ìë™ ë¶€ì—¬</label>
  </div>
  <div class="row"><button id="mergeBtn" disabled>ë³‘í•© ì‹¤í–‰</button></div>
  <div class="row tip">ë§¤ì¹­ ê·œì¹™: ëŒ€ì†Œë¬¸ì ë¬´ì‹œ Â· ê³µë°±/í•˜ì´í”ˆ ì œê±° Â· Blender ì ‘ë¯¸ì‚¬(.001 / _001 ë“±) ì œê±° Â· ì¢Œ/ìš°(.L/.R ë“±) í‘œì¤€í™” Â· Levenshtein í¼ì§€ ë§¤ì¹­(ì„ê³„ì¹˜ 0.82)</div>
  <pre id="log"></pre>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

    const logEl = document.getElementById('log');
    const log = (...a) => { console.log(...a); logEl.textContent += a.join(' ') + '\\n'; };

    const loader = new GLTFLoader();
    const exporter = new GLTFExporter();

    let gltfA = null;
    let gltfB = null;

    document.getElementById('fileA').addEventListener('change', e => {
      const f = e.target.files[0];
      if (f) {
        const url = URL.createObjectURL(f);
        loader.load(url, g => {
          gltfA = g;
          log('a.glb ë¡œë“œ ì™„ë£Œ:', f.name, 'animations:', g.animations.length);
          URL.revokeObjectURL(url);
          checkReady();
        });
      }
    });

    document.getElementById('fileB').addEventListener('change', e => {
      const f = e.target.files[0];
      if (f) {
        const url = URL.createObjectURL(f);
        loader.load(url, g => {
          gltfB = g;
          log('b.glb ë¡œë“œ ì™„ë£Œ:', f.name, 'animations:', g.animations.length);
          URL.revokeObjectURL(url);
          checkReady();
        });
      }
    });

    function checkReady() {
      document.getElementById('mergeBtn').disabled = !(gltfA && gltfB);
    }

    // ---------- íœ´ë¦¬ìŠ¤í‹± ìœ í‹¸ ----------
    function normalizeSide(name){
      let n = name.replace(/\.l\b/gi,'_l').replace(/\.r\b/gi,'_r');
      n = n.replace(/[\s\-]+l\b/gi,'_l').replace(/[\s\-]+r\b/gi,'_r');
      return n;
    }
    function stripNumericSuffix(name){
      let n = name;
      for(let i=0;i<3;i++){
        n = n.replace(/([_\-\.\s]?\(?\d{1,4}\)?)$/,''); // ë ìˆ«ì/êµ¬ë¶„ì ì œê±°
      }
      return n;
    }
    function canonicalKey(name){
      if(!name) return '';
      let n = normalizeSide(name);
      n = stripNumericSuffix(n);
      n = n.toLowerCase();
      n = n.replace(/[^a-z0-9_]/g,''); // ê³µë°±/íŠ¹ìˆ˜ë¬¸ì ì œê±°
      n = n.replace(/_+/g,'_').replace(/^_+|_+$/g,'');
      return n;
    }
    function levenshtein(a,b){
      const m=a.length, n=b.length;
      if(m===0) return n;
      if(n===0) return m;
      const dp = new Array(n+1);
      for(let j=0;j<=n;j++) dp[j]=j;
      for(let i=1;i<=m;i++){
        let prev = dp[0];
        dp[0]=i;
        for(let j=1;j<=n;j++){
          const tmp = dp[j];
          const cost = a[i-1]===b[j-1]?0:1;
          dp[j] = Math.min(dp[j]+1, dp[j-1]+1, prev+cost);
          prev = tmp;
        }
      }
      return dp[n];
    }
    function similarity(a,b){
      if(!a || !b) return 0;
      const d = levenshtein(a,b);
      const L = Math.max(a.length,b.length);
      return 1 - d / (L||1);
    }
    function buildANodeIndex(scene){
      const idx = new Map();
      const originals = new Set();
      scene.traverse(obj=>{
        if(!obj.name) return;
        const raw = obj.name;
        originals.add(raw);
        const key = canonicalKey(raw);
        if(!key) return;
        if(!idx.has(key)) idx.set(key,new Set());
        idx.get(key).add(raw);
      });
      return { idx, originals };
    }
    function pickBestMatch(bNodeRaw, aIndex){
      const bKey = canonicalKey(bNodeRaw);
      if(aIndex.idx.has(bKey)){
        const cands = Array.from(aIndex.idx.get(bKey));
        // ê°€ì¥ ë¹„ìŠ·í•œ ê¸¸ì´ì˜ í›„ë³´
        let best = cands[0], bestScore = -1;
        for(const c of cands){
          const s = similarity(canonicalKey(c), bKey);
          if(s>bestScore){bestScore=s;best=c;}
        }
        return { name: best, score: 1.0, reason: 'exact-key' };
      }
      const bStripped = canonicalKey(stripNumericSuffix(normalizeSide(bNodeRaw)));
      if(aIndex.idx.has(bStripped)){
        const cands = Array.from(aIndex.idx.get(bStripped));
        return { name: cands[0], score: 0.98, reason: 'stripped-suffix' };
      }
      const bSideNorm = canonicalKey(normalizeSide(bNodeRaw));
      if(aIndex.idx.has(bSideNorm)){
        const cands = Array.from(aIndex.idx.get(bSideNorm));
        return { name: cands[0], score: 0.96, reason: 'side-normalized' };
      }
      const threshold = 0.82;
      let bestName = null, bestScore = 0, bestReason = 'fuzzy';
      for(const [aKey, setRaw] of aIndex.idx.entries()){
        const s = similarity(bKey, aKey);
        if(s > bestScore){
          bestScore = s;
          bestName = setRaw.values().next().value;
        }
      }
      if(bestScore >= threshold){
        return { name: bestName, score: bestScore, reason: bestReason };
      }
      return null;
    }

    // ---------- í´ë¦½ ì´ë¦„ ê³ ìœ í™” ----------
    function uniqueName(base, taken){
      let name = base && base.trim() ? base.trim() : 'Clip';
      if(!taken.has(name)){
        taken.add(name);
        return name;
      }
      // ë’¤ì— ë²ˆí˜¸ ì¦ê°€
      let i = 1;
      while(taken.has(`${name}_${i}`)) i++;
      const finalName = `${name}_${i}`;
      taken.add(finalName);
      return finalName;
    }

    document.getElementById('mergeBtn').addEventListener('click', () => {
      if (!gltfA || !gltfB) return;

      const aIndex = buildANodeIndex(gltfA.scene);
      log('a.glb ë…¸ë“œ ìˆ˜(ì´ë¦„ ë³´ìœ ):', aIndex.originals.size);

      // 1) a.glbì˜ ì• ë‹ˆë©”ì´ì…˜ ì´ë¦„ ëª©ë¡ ìˆ˜ì§‘
      const takenNames = new Set();
      for(const c of gltfA.animations || []){
        const old = c.name && c.name.trim() ? c.name : 'Animation';
        const uniq = uniqueName(old, takenNames);
        // aì˜ ì´ë¦„ì€ ë°”ê¾¸ì§€ ì•Šê³  ì˜ˆì•½ë§Œ
        if(uniq !== old){
          // ì˜ˆì•½ ì¶©ëŒ ì‹œì—ë„ aëŠ” ê·¸ëŒ€ë¡œ ë‘ê³ , ì´í›„ bì—ì„œ í”¼í•´ì„œ ì´ë¦„ ìƒì„±
          // (í•„ìš”í•˜ë©´ ì—¬ê¸°ì„œ a ì´ë¦„ë„ ë°”ê¾¸ë„ë¡ ì˜µì…˜í™” ê°€ëŠ¥)
        }
      }

      // 2) b.glb ì• ë‹ˆë©”ì´ì…˜ â†’ a ë…¸ë“œë¡œ ë§¤í•‘ + í´ë¦½ëª… ê³ ìœ í™”/ì ‘ë‘ì‚¬
      const mappedBAnims = [];
      let totalTracks = 0, mappedTracks = 0;
      const addPrefix = document.getElementById('prefixB').checked;

      let seq = 1;
      for (const clip of gltfB.animations) {
        const newTracks = [];

        for (const track of clip.tracks) {
          totalTracks++;
          const parts = track.name.split('.');
          const bNode = parts[0];
          const match = pickBestMatch(bNode, aIndex);
          if (match) {
            const cloned = track.clone();
            cloned.name = cloned.name.replace(bNode, match.name);
            newTracks.push(cloned);
            mappedTracks++;
            log('ğŸ§© ë§¤í•‘:', bNode, 'â†’', match.name, `(reason=${match.reason}, score=${match.score.toFixed(3)})`);
          } else {
            log('âš ï¸ ë§¤ì¹˜ ì‹¤íŒ¨:', bNode);
          }
        }

        if (newTracks.length > 0) {
          const newClip = clip.clone();
          newClip.tracks = newTracks;

          // ê¸°ë³¸ ì´ë¦„ ê²°ì •
          let baseName = clip.name && clip.name.trim() ? clip.name.trim() : 'Animation';
          // "Animation"ì²˜ëŸ¼ í”í•œ ì´ë¦„ì—ëŠ” ì ‘ë‘ì‚¬/ë²ˆí˜¸ ë¶€ì—¬
          if (addPrefix) baseName = `b_${baseName}`;
          // takenNamesë¥¼ í”¼í•´ ê³ ìœ  ì´ë¦„ ìƒì„±
          newClip.name = uniqueName(baseName, takenNames);

          mappedBAnims.push(newClip);
          log(`í´ë¦½ "${clip.name}" â†’ "${newClip.name}" (${newTracks.length} íŠ¸ë™ ë§¤í•‘ ì„±ê³µ)`);
          seq++;
        } else {
          log(`í´ë¦½ "${clip.name}" ë§¤í•‘ëœ íŠ¸ë™ ì—†ìŒ â†’ ìŠ¤í‚µ`);
        }
      }

      log(`ìš”ì•½: ì´ íŠ¸ë™ ${totalTracks}ê°œ ì¤‘ ${mappedTracks}ê°œ ë§¤í•‘ ì„±ê³µ`);

      // 3) ë³‘í•© (a ì›ë³¸ + b ë§¤í•‘ë³¸)
      const mergedAnims = [...gltfA.animations, ...mappedBAnims];
      log(`ìµœì¢… ë³‘í•© ì• ë‹ˆë©”ì´ì…˜ ê°œìˆ˜: ${mergedAnims.length}`);

      exporter.parse(
        gltfA.scene,
        (result) => {
          const blob = new Blob([result], { type: 'model/gltf-binary' });
          const url = URL.createObjectURL(blob);
          const aTag = document.createElement('a');
          aTag.href = url;
          aTag.download = 'merged.glb';
          document.body.appendChild(aTag);
          aTag.click();
          document.body.removeChild(aTag);
          URL.revokeObjectURL(url);
          log('%câœ… ë³‘í•© ì™„ë£Œ, merged.glb ë‹¤ìš´ë¡œë“œ','color:#8df59b');
          log('ì¬ìƒ íŒ: three.jsì—ì„œ AnimationMixer.clipAction( animations.find(c=>c.name==="b_Animation") ) ì²˜ëŸ¼ ì´ë¦„ìœ¼ë¡œ ì„ íƒí•˜ì„¸ìš”.');
        },
        (err) => {
          console.error(err);
          log('%câŒ ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨:','color:#ff6b6b', err);
        },
        { binary: true, animations: mergedAnims }
      );
    });
  </script>
</body>
</html>